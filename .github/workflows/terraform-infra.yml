name: Terraform CI/CD for DOKS Infra

on:
  pull_request:
    branches:
      - main
    paths:
      - 'infra/terraform/doks/**'
      - 'infra/k8s/cert-manager/**'  # Adicionado path dos recursos Kubernetes

  push:
    branches:
      - main
    paths:
      - 'infra/terraform/doks/**'
      - 'infra/k8s/cert-manager/**'  # Adicionado path dos recursos Kubernetes

permissions:
  contents: read # Necess√°rio para actions/checkout
  # pull-requests: write # Descomente se precisar que o bot comente o plano no PR

jobs:
  terraform_plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' # Executa apenas em Pull Requests

    env:
      # DIGITALOCEAN_ACCESS_TOKEN removido daqui, ser√° pego do TF Cloud
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      # Garante que o Terraform n√£o pe√ßa input interativo
      TF_INPUT: false
      # Informa ao provider que est√° rodando em automa√ß√£o
      TF_IN_AUTOMATION: true

    defaults:
      run:
        shell: bash
        working-directory: ./infra/terraform/doks # Define o diret√≥rio de trabalho

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.7.x # Especifique a vers√£o do Terraform ou deixe "latest"
        # terraform_wrapper: true # Opcional: pode ajudar com output

    - name: Terraform Format Check
      id: fmt
      run: terraform fmt -check
      continue-on-error: true # Permite continuar mesmo se houver erro de formata√ß√£o

    - name: Terraform Init
      id: init
      # N√£o precisa mais passar backend-config para o init
      run: terraform init

    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color

    - name: Run Terraform Plan
      id: plan
      run: terraform plan -no-color
      continue-on-error: true # Permite que o workflow continue se o plan falhar (para reportar erro)

    # Opcional: Adicionar um passo para comentar o plano no PR
    # - name: Comment Plan on PR
    #   uses: actions/github-script@v6
    #   if: github.event_name == 'pull_request'
    #   with:
    #     github-token: ${{ secrets.GITHUB_TOKEN }} # Precisa da permiss√£o pull-requests: write
    #     script: |-
    #       const output = `#### Terraform Format and Style üñå\\\`\\\`\\\`
    #       ${{ steps.fmt.outcome }} 
    #       \\\`\\\`\\\`
    #       #### Terraform Initialization ‚öôÔ∏è\\\`\\\`\\\`
    #       ${{ steps.init.outcome }}
    #       \\\`\\\`\\\`
    #       #### Terraform Validation ü§ñ\\\`\\\`\\\`
    #       ${{ steps.validate.outcome }}
    #       \\\`\\\`\\\`
    #       <details><summary>Validation Output</summary>
    #       \\\`\\\`\\\`
    #       ${{ steps.validate.outputs.stdout }}
    #       \\\`\\\`\\\`
    #       </details>
    #       #### Terraform Plan üìñ\\\`\\\`\\\`
    #       ${{ steps.plan.outcome }}
    #       \\\`\\\`\\\`
    #       <details><summary>Show Plan</summary>
    #       \\\`\\\`\\\`terraform
    #       ${{ steps.plan.outputs.stdout }}
    #       \\\`\\\`\\\`
    #       </details>
    #       *Pusher: @${{ github.actor }}, Action: \\\`\\\`${{ github.event_name }}\\\`\\\`, Working Directory: \\\`\\\`${{ env.tf_actions_working_dir }}\\\`\\\`, Workflow: \\\`\\\`${{ github.workflow }}\\\`\\\`*`;
    #       github.rest.issues.createComment({
    #         issue_number: context.issue.number,
    #         owner: context.repo.owner,
    #         repo: context.repo.repo,
    #         body: output
    #       })

    - name: Check Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1 # Falha o workflow se o plan falhar

  terraform_apply:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' # Executa apenas em push para main
    timeout-minutes: 30   # Aumentar timeout para dar tempo suficiente ao Helm

    env:
      # DIGITALOCEAN_ACCESS_TOKEN removido daqui, ser√° pego do TF Cloud
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      TF_INPUT: false
      TF_IN_AUTOMATION: true

    defaults:
      run:
        shell: bash
        working-directory: ./infra/terraform/doks

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.7.x # Use a mesma vers√£o do job de plan

    - name: Terraform Init
      id: init
      # N√£o precisa mais passar backend-config para o init
      run: terraform init

    - name: Terraform Apply
      id: apply
      run: terraform apply -auto-approve -no-color
      
    # Novos passos para aplicar recursos Kubernetes
    - name: Obter Kubeconfig
      id: get_kubeconfig
      run: |
        # Aguarda a cria√ß√£o do cluster (pode ser necess√°rio ajustar o tempo)
        sleep 30
        
        # Exporta o kubeconfig do Terraform
        terraform output -raw kubeconfig > kubeconfig.yaml || \
        echo "N√£o foi poss√≠vel obter kubeconfig diretamente, tentando com cluster_id"
        
        # Se n√£o conseguir diretamente, tenta com cluster_id via doctl
        if [ ! -s kubeconfig.yaml ]; then
          # Instala doctl se necess√°rio
          CLUSTER_ID=$(terraform output -raw cluster_id)
          echo "Usando cluster_id: $CLUSTER_ID"
          
          # Instalar doctl
          curl -sL https://github.com/digitalocean/doctl/releases/download/v1.104.0/doctl-1.104.0-linux-amd64.tar.gz | tar -xzv
          sudo mv doctl /usr/local/bin
          
          # Autenticar doctl
          doctl auth init -t ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          
          # Obter kubeconfig
          doctl kubernetes cluster kubeconfig save $CLUSTER_ID
          cp ~/.kube/config kubeconfig.yaml
        fi
        
        echo "KUBECONFIG_PATH=${PWD}/kubeconfig.yaml" >> $GITHUB_ENV
        echo "Kubeconfig gerado em ${PWD}/kubeconfig.yaml"
    
    - name: Instalar kubectl
      uses: azure/setup-kubectl@v3
      
    - name: Aguardar disponibilidade do cert-manager
      run: |
        echo "Aguardando disponibilidade do cert-manager..."
        # Tenta por at√© 5 minutos (30 tentativas com 10s de intervalo)
        for i in {1..30}; do
          if kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} get deployment cert-manager -n cert-manager 2>/dev/null; then
            echo "Cert-manager encontrado, aguardando disponibilidade..."
            kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} wait --for=condition=available --timeout=30s deployment/cert-manager -n cert-manager && \
            kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} wait --for=condition=available --timeout=30s deployment/cert-manager-webhook -n cert-manager && \
            break
          fi
          echo "Tentativa $i: Aguardando cert-manager ser instalado..."
          sleep 10
        done
      
    - name: Aplicar ClusterIssuer
      run: |
        echo "Aplicando ClusterIssuer..."
        kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} apply -f ${GITHUB_WORKSPACE}/infra/k8s/cert-manager/cluster-issuer.yaml
        echo "ClusterIssuer aplicado com sucesso!"
      
    - name: Verificar status do ClusterIssuer
      run: |
        echo "Verificando status do ClusterIssuer..."
        sleep 15  # Aguardar a aplica√ß√£o do recurso
        kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} get clusterissuer letsencrypt-prod -o wide
      
    - name: Obter IP do Load Balancer
      id: get_lb_ip
      run: |
        # Continua com a obten√ß√£o do IP como antes
        echo "Aguardando provisionamento do Load Balancer..."
        sleep 60  # Tempo de espera para garantir que o Load Balancer esteja pronto
        
        # Tenta obter o IP
        LB_IP=$(terraform output -raw load_balancer_ip || echo "n√£o dispon√≠vel")
        echo "LOAD_BALANCER_IP=${LB_IP}" >> $GITHUB_ENV
        echo "Load Balancer IP: ${LB_IP}"
    
    - name: Exibir informa√ß√µes importantes
      run: |
        echo "============================================="
        echo "üöÄ Cluster criado/atualizado com sucesso!"
        echo "üìã Informa√ß√µes importantes:"
        echo "   - IP do Load Balancer: ${{ env.LOAD_BALANCER_IP }}"
        echo "   - Host para DNS: api.urbanadobrasil.com"
        echo "============================================="
        echo "‚ö†Ô∏è IMPORTANTE: Atualize seu DNS para apontar api.urbanadobrasil.com para o IP ${{ env.LOAD_BALANCER_IP }}"
        echo "=============================================" 