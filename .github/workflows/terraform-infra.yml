name: Terraform CI/CD for DOKS Infra

on:
  pull_request:
    branches:
      - main
    paths:
      - 'infra/terraform/doks/**'
      - 'infra/k8s/cert-manager/**'  # Adicionado path dos recursos Kubernetes

  push:
    branches:
      - main
    paths:
      - 'infra/terraform/doks/**'
      - 'infra/k8s/cert-manager/**'  # Adicionado path dos recursos Kubernetes

permissions:
  contents: read # Necess치rio para actions/checkout
  # pull-requests: write # Descomente se precisar que o bot comente o plano no PR

jobs:
  terraform_plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' # Executa apenas em Pull Requests

    env:
      # DIGITALOCEAN_ACCESS_TOKEN removido daqui, ser치 pego do TF Cloud
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      # Garante que o Terraform n칚o pe칞a input interativo
      TF_INPUT: false
      # Informa ao provider que est치 rodando em automa칞칚o
      TF_IN_AUTOMATION: true

    defaults:
      run:
        shell: bash
        working-directory: ./infra/terraform/doks # Define o diret칩rio de trabalho

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.7.x # Especifique a vers칚o do Terraform ou deixe "latest"
        # terraform_wrapper: true # Opcional: pode ajudar com output

    - name: Terraform Format Check
      id: fmt
      run: terraform fmt -check
      continue-on-error: true # Permite continuar mesmo se houver erro de formata칞칚o

    - name: Terraform Init
      id: init
      # N칚o precisa mais passar backend-config para o init
      run: terraform init

    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color

    - name: Run Terraform Plan
      id: plan
      run: terraform plan -no-color
      continue-on-error: true # Permite que o workflow continue se o plan falhar (para reportar erro)

    # Opcional: Adicionar um passo para comentar o plano no PR
    # - name: Comment Plan on PR
    #   uses: actions/github-script@v6
    #   if: github.event_name == 'pull_request'
    #   with:
    #     github-token: ${{ secrets.GITHUB_TOKEN }} # Precisa da permiss칚o pull-requests: write
    #     script: |-
    #       const output = `#### Terraform Format and Style 游둛\\\`\\\`\\\`
    #       ${{ steps.fmt.outcome }} 
    #       \\\`\\\`\\\`
    #       #### Terraform Initialization 丘뙖잺\\\`\\\`\\\`
    #       ${{ steps.init.outcome }}
    #       \\\`\\\`\\\`
    #       #### Terraform Validation 游뱄\\\`\\\`\\\`
    #       ${{ steps.validate.outcome }}
    #       \\\`\\\`\\\`
    #       <details><summary>Validation Output</summary>
    #       \\\`\\\`\\\`
    #       ${{ steps.validate.outputs.stdout }}
    #       \\\`\\\`\\\`
    #       </details>
    #       #### Terraform Plan 游닀\\\`\\\`\\\`
    #       ${{ steps.plan.outcome }}
    #       \\\`\\\`\\\`
    #       <details><summary>Show Plan</summary>
    #       \\\`\\\`\\\`terraform
    #       ${{ steps.plan.outputs.stdout }}
    #       \\\`\\\`\\\`
    #       </details>
    #       *Pusher: @${{ github.actor }}, Action: \\\`\\\`${{ github.event_name }}\\\`\\\`, Working Directory: \\\`\\\`${{ env.tf_actions_working_dir }}\\\`\\\`, Workflow: \\\`\\\`${{ github.workflow }}\\\`\\\`*`;
    #       github.rest.issues.createComment({
    #         issue_number: context.issue.number,
    #         owner: context.repo.owner,
    #         repo: context.repo.repo,
    #         body: output
    #       })

    - name: Check Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1 # Falha o workflow se o plan falhar

  terraform_apply:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push' # Executa apenas em push para main
    timeout-minutes: 30   # Aumentar timeout para dar tempo suficiente ao Helm

    env:
      # DIGITALOCEAN_ACCESS_TOKEN removido daqui, ser치 pego do TF Cloud
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
      TF_INPUT: false
      TF_IN_AUTOMATION: true

    defaults:
      run:
        shell: bash
        working-directory: ./infra/terraform/doks

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.7.x # Use a mesma vers칚o do job de plan

    - name: Terraform Init
      id: init
      # N칚o precisa mais passar backend-config para o init
      run: terraform init

    # Novo passo para importar recursos existentes para o estado do Terraform
    - name: Importar recursos existentes (se necess치rio)
      run: |
        # Configura acesso ao cluster primeiro para verificar
        if [ -f ~/.kube/config ]; then
          echo "Usando configura칞칚o kubectl existente"
        else
          # Tenta obter acesso ao cluster via token DigitalOcean
          # Isto s칩 funcionar치 se o cluster j치 existir
          echo "Tentando acessar cluster existente..."
          
          # Instalar doctl se necess치rio
          curl -sL https://github.com/digitalocean/doctl/releases/download/v1.104.0/doctl-1.104.0-linux-amd64.tar.gz | tar -xzv
          sudo mv doctl /usr/local/bin
          
          # Autenticar doctl
          doctl auth init -t ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          
          # Tentar obter cluster_id do estado remoto ou output
          CLUSTER_ID=$(terraform output -raw cluster_id 2>/dev/null || echo "")
          
          if [ -n "$CLUSTER_ID" ]; then
            echo "Encontrado cluster ID: $CLUSTER_ID"
            # Obter kubeconfig
            doctl kubernetes cluster kubeconfig save $CLUSTER_ID
          else
            echo "N칚o foi poss칤vel obter cluster_id, prosseguindo sem verifica칞칚o"
          fi
        fi
        
        # Verifica se o namespace j치 existe e importa para o Terraform
        if kubectl get namespace urbana-connect 2>/dev/null; then
          echo "Namespace urbana-connect j치 existe, importando para o estado do Terraform..."
          terraform state list kubernetes_namespace.urbana_connect 2>/dev/null || \
          terraform import kubernetes_namespace.urbana_connect urbana-connect || \
          echo "Importa칞칚o falhou ou n칚o foi necess치ria (namespace possivelmente j치 no estado)"
        else
          echo "Namespace urbana-connect n칚o existe, ser치 criado pelo Terraform"
        fi
      continue-on-error: true  # Continua mesmo se a importa칞칚o falhar

    - name: Terraform Apply
      id: apply
      run: terraform apply -auto-approve -no-color
      
    # Novos passos para aplicar recursos Kubernetes
    - name: Obter Kubeconfig
      id: get_kubeconfig
      run: |
        # Aguarda a cria칞칚o do cluster (pode ser necess치rio ajustar o tempo)
        sleep 30
        
        # Exporta o kubeconfig do Terraform
        terraform output -raw kubeconfig > kubeconfig.yaml || \
        echo "N칚o foi poss칤vel obter kubeconfig diretamente, tentando com cluster_id"
        
        # Se n칚o conseguir diretamente, tenta com cluster_id via doctl
        if [ ! -s kubeconfig.yaml ]; then
          # Instala doctl se necess치rio
          CLUSTER_ID=$(terraform output -raw cluster_id)
          echo "Usando cluster_id: $CLUSTER_ID"
          
          # Instalar doctl
          curl -sL https://github.com/digitalocean/doctl/releases/download/v1.104.0/doctl-1.104.0-linux-amd64.tar.gz | tar -xzv
          sudo mv doctl /usr/local/bin
          
          # Autenticar doctl
          doctl auth init -t ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          
          # Obter kubeconfig
          doctl kubernetes cluster kubeconfig save $CLUSTER_ID
          cp ~/.kube/config kubeconfig.yaml
        fi
        
        echo "KUBECONFIG_PATH=${PWD}/kubeconfig.yaml" >> $GITHUB_ENV
        echo "Kubeconfig gerado em ${PWD}/kubeconfig.yaml"
    
    - name: Instalar kubectl
      uses: azure/setup-kubectl@v3
      
    - name: Aguardar disponibilidade do cert-manager
      run: |
        echo "Aguardando disponibilidade do cert-manager..."
        # Tenta por at칠 5 minutos (30 tentativas com 10s de intervalo)
        for i in {1..30}; do
          if kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} get deployment cert-manager -n cert-manager 2>/dev/null; then
            echo "Cert-manager encontrado, aguardando disponibilidade..."
            kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} wait --for=condition=available --timeout=30s deployment/cert-manager -n cert-manager && \
            kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} wait --for=condition=available --timeout=30s deployment/cert-manager-webhook -n cert-manager && \
            break
          fi
          echo "Tentativa $i: Aguardando cert-manager ser instalado..."
          sleep 10
        done
      
    - name: Aplicar ClusterIssuer
      run: |
        echo "Aplicando ClusterIssuer..."
        kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} apply -f ${GITHUB_WORKSPACE}/infra/k8s/cert-manager/cluster-issuer.yaml
        echo "ClusterIssuer aplicado com sucesso!"
      
    - name: Verificar status do ClusterIssuer
      run: |
        echo "Verificando status do ClusterIssuer..."
        sleep 15  # Aguardar a aplica칞칚o do recurso
        kubectl --kubeconfig=${{ env.KUBECONFIG_PATH }} get clusterissuer letsencrypt-prod -o wide
    
    - name: Obter IP do Load Balancer
      id: get_lb_ip
      run: |
        # Continua com a obten칞칚o do IP como antes
        echo "Aguardando provisionamento do Load Balancer..."
        sleep 60  # Tempo de espera para garantir que o Load Balancer esteja pronto
        
        # Tenta obter o IP
        LB_IP=$(terraform output -raw load_balancer_ip || echo "n칚o dispon칤vel")
        echo "LOAD_BALANCER_IP=${LB_IP}" >> $GITHUB_ENV
        echo "Load Balancer IP: ${LB_IP}"
    
    - name: Exibir informa칞칫es importantes
      run: |
        echo "============================================="
        echo "游 Cluster criado/atualizado com sucesso!"
        echo "游늶 Informa칞칫es importantes:"
        echo "   - IP do Load Balancer: ${{ env.LOAD_BALANCER_IP }}"
        echo "   - Host para DNS: api.urbanadobrasil.com"
        echo "============================================="
        echo "丘멆잺 IMPORTANTE: Atualize seu DNS para apontar api.urbanadobrasil.com para o IP ${{ env.LOAD_BALANCER_IP }}"
        echo "=============================================" 